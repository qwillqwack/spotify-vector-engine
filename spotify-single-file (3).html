<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spotify Vector Music Engine</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // Lucide Icons as inline SVG components
    const Music = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
      </svg>
    );

    const Sparkles = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
      </svg>
    );

    const Loader2 = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 2v4m0 12v4M4.93 4.93l2.83 2.83m8.48 8.48l2.83 2.83M2 12h4m12 0h4M4.93 19.07l2.83-2.83m8.48-8.48l2.83-2.83" />
      </svg>
    );

    const Plus = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
      </svg>
    );

    const X = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
      </svg>
    );

    const Zap = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
      </svg>
    );

    const LogIn = ({ className }) => (
      <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 16l-4-4m0 0l4-4m-4 4h14m-5 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h7a3 3 0 013 3v1" />
      </svg>
    );

    function SpotifyVectorRecommender() {
      const [currentInput, setCurrentInput] = useState('');
      const [songList, setSongList] = useState([]);
      const [loading, setLoading] = useState(false);
      const [vectorizing, setVectorizing] = useState(false);
      const [recommendations, setRecommendations] = useState([]);
      const [vectorProfile, setVectorProfile] = useState(null);
      const [error, setError] = useState('');
      const [spotifyToken, setSpotifyToken] = useState(null);
      const [spotifyUser, setSpotifyUser] = useState(null);
      const [fetchingSpotify, setFetchingSpotify] = useState(false);
      const [uploadingCSV, setUploadingCSV] = useState(false);

      // Spotify Config
      const SPOTIFY_CLIENT_ID = 'cbd184dc3ce14cc49017747f268f5eba';
      const REDIRECT_URI = 'https://precious-granita-28bae6.netlify.app/';
      const SCOPES = 'user-top-read user-read-private';

      useEffect(() => {
        const hash = window.location.hash;
        if (hash) {
          const params = new URLSearchParams(hash.substring(1));
          const token = params.get('access_token');
          if (token) {
            setSpotifyToken(token);
            window.history.replaceState({}, document.title, window.location.pathname);
            fetchSpotifyData(token);
          }
        }
      }, []);

      const loginWithSpotify = () => {
        // Use PKCE flow instead of implicit
        const codeVerifier = generateCodeVerifier();
        localStorage.setItem('code_verifier', codeVerifier);
        
        generateCodeChallenge(codeVerifier).then(codeChallenge => {
          const authUrl = `https://accounts.spotify.com/authorize?client_id=${SPOTIFY_CLIENT_ID}&response_type=code&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&scope=${encodeURIComponent(SCOPES)}&code_challenge_method=S256&code_challenge=${codeChallenge}`;
          window.location.href = authUrl;
        });
      };

      const generateCodeVerifier = () => {
        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        const randomValues = crypto.getRandomValues(new Uint8Array(64));
        return randomValues.reduce((acc, x) => acc + possible[x % possible.length], '');
      };

      const generateCodeChallenge = async (verifier) => {
        const data = new TextEncoder().encode(verifier);
        const hashed = await crypto.subtle.digest('SHA-256', data);
        return btoa(String.fromCharCode(...new Uint8Array(hashed)))
          .replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
      };

      const fetchSpotifyData = async (token) => {
        setFetchingSpotify(true);
        try {
          const userResponse = await fetch('https://api.spotify.com/v1/me', {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          const userData = await userResponse.json();
          setSpotifyUser(userData);

          const tracksResponse = await fetch('https://api.spotify.com/v1/me/top/tracks?limit=20&time_range=medium_term', {
            headers: { 'Authorization': `Bearer ${token}` }
          });
          const tracksData = await tracksResponse.json();

          if (tracksData.items) {
            const tracks = tracksData.items.map(track => 
              `${track.name} by ${track.artists[0].name}`
            );
            setSongList(tracks);
          }
        } catch (err) {
          setError('Failed to fetch Spotify data. Try manual input instead.');
          console.error(err);
        } finally {
          setFetchingSpotify(false);
        }
      };

      const addSong = () => {
        if (currentInput.trim() && !songList.includes(currentInput.trim())) {
          setSongList([...songList, currentInput.trim()]);
          setCurrentInput('');
          setError('');
        }
      };

      const removeSong = (index) => {
        setSongList(songList.filter((_, i) => i !== index));
        setVectorProfile(null);
        setRecommendations([]);
      };

      const handleCSVUpload = (event) => {
        const files = event.target.files;
        if (!files || files.length === 0) return;

        setUploadingCSV(true);
        const allSongs = [];

        Array.from(files).forEach((file, index) => {
          Papa.parse(file, {
            header: true,
            complete: (results) => {
              results.data.forEach(row => {
                // Try different common CSV column names
                const track = row['Track Name'] || row['track_name'] || row['name'] || row['Track'] || row['Song'];
                const artist = row['Artist Name'] || row['artist_name'] || row['artist'] || row['Artist'] || row['artists'];
                
                if (track && artist) {
                  const songString = `${track} by ${artist}`;
                  if (!allSongs.includes(songString)) {
                    allSongs.push(songString);
                  }
                } else if (track) {
                  if (!allSongs.includes(track)) {
                    allSongs.push(track);
                  }
                }
              });

              // If this is the last file, update state
              if (index === files.length - 1) {
                setSongList(prev => [...new Set([...prev, ...allSongs])]);
                setUploadingCSV(false);
                setError('');
              }
            },
            error: (error) => {
              console.error('CSV parse error:', error);
              setError('Failed to parse CSV. Make sure it has track/artist columns.');
              setUploadingCSV(false);
            }
          });
        });
      };

      const vectorizeProfile = async () => {
        if (songList.length === 0) {
          setError('Add at least one song first');
          return;
        }

        setVectorizing(true);
        setError('');

        try {
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 1000,
              messages: [{
                role: 'user',
                content: `You are a music analysis AI. Analyze these songs and create a vectorized profile:

${songList.slice(0, 20).map((s, i) => `${i + 1}. ${s}`).join('\n')}

Create a multi-dimensional vector profile capturing:
- Genres (with weights 0-1)
- Moods/emotions (with weights 0-1)
- Energy level (0-1)
- Tempo preference (slow/medium/fast with weights)
- Era/decade preferences
- Instrumentation preferences
- Lyrical themes

Respond ONLY with JSON (no markdown):
{
  "profile": {
    "genres": {"rock": 0.8, "indie": 0.6, ...},
    "moods": {"energetic": 0.9, "melancholic": 0.3, ...},
    "energy": 0.75,
    "tempo": {"slow": 0.2, "medium": 0.5, "fast": 0.8},
    "eras": {"1970s": 0.4, "2000s": 0.7, ...},
    "instrumentation": {"guitar": 0.9, "synth": 0.6, ...},
    "themes": {"love": 0.5, "rebellion": 0.8, ...}
  },
  "summary": "Brief description of this music taste profile"
}`
              }]
            })
          });

          const data = await response.json();
          const textContent = data.content
            .filter(item => item.type === 'text')
            .map(item => item.text)
            .join('');

          const cleanText = textContent.replace(/```json|```/g, '').trim();
          const parsed = JSON.parse(cleanText);
          
          setVectorProfile(parsed);
        } catch (err) {
          setError('Failed to vectorize. Please try again.');
          console.error(err);
        } finally {
          setVectorizing(false);
        }
      };

      const generateRecommendations = async () => {
        if (!vectorProfile) {
          setError('Vectorize your profile first');
          return;
        }

        setLoading(true);
        setError('');

        try {
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 1000,
              messages: [{
                role: 'user',
                content: `Based on this vectorized music profile:
${JSON.stringify(vectorProfile.profile, null, 2)}

Generate 6 song recommendations that match this vector profile. Use cosine similarity logic - recommend songs that score highly across the weighted dimensions.

Respond ONLY with JSON (no markdown):
{
  "recommendations": [
    {
      "song": "Song Name",
      "artist": "Artist Name",
      "matchScore": 0.85,
      "matchReason": "Brief explanation of vector alignment"
    }
  ]
}`
              }]
            })
          });

          const data = await response.json();
          const textContent = data.content
            .filter(item => item.type === 'text')
            .map(item => item.text)
            .join('');

          const cleanText = textContent.replace(/```json|```/g, '').trim();
          const parsed = JSON.parse(cleanText);
          
          setRecommendations(parsed.recommendations || []);
        } catch (err) {
          setError('Failed to generate recommendations. Please try again.');
          console.error(err);
        } finally {
          setLoading(false);
        }
      };

      return (
        <div className="min-h-screen bg-gradient-to-br from-green-900 via-black to-purple-900 p-4 md:p-8">
          <div className="max-w-6xl mx-auto">
            <div className="text-center mb-8">
              <div className="flex items-center justify-center gap-3 mb-4">
                <Zap className="w-12 h-12 text-green-400" />
                <h1 className="text-4xl md:text-5xl font-bold text-white">Spotify Vector Engine</h1>
              </div>
              <p className="text-green-200 text-lg">
                AI-powered vectorization â€¢ Content-based recommendations
              </p>
            </div>

            {!spotifyToken && (
              <div className="bg-green-500/10 backdrop-blur-lg rounded-2xl p-8 border border-green-500/30 mb-6 text-center">
                <Music className="w-16 h-16 text-green-400 mx-auto mb-4" />
                <h2 className="text-2xl font-bold text-white mb-2">Connect Your Spotify</h2>
                <p className="text-green-200 mb-4">
                  Get your token from Spotify Console
                </p>
                <div className="max-w-md mx-auto mb-4">
                  <input
                    type="text"
                    placeholder="Paste your Spotify access token here..."
                    className="w-full px-4 py-3 rounded-lg bg-white/20 text-white placeholder-green-300 border border-green-500/30 focus:outline-none focus:ring-2 focus:ring-green-400 mb-3"
                    onChange={(e) => {
                      if (e.target.value.length > 20) {
                        setSpotifyToken(e.target.value);
                        fetchSpotifyData(e.target.value);
                      }
                    }}
                  />
                  <p className="text-green-300 text-sm">
                    Get token: <a href="https://developer.spotify.com/console/get-current-user-top-artists-and-tracks/" target="_blank" className="underline text-green-400">Spotify Console</a>
                  </p>
                </div>
                <p className="text-green-300 text-sm mt-4">
                  Or skip and add songs manually below
                </p>
              </div>
            )}

            {spotifyUser && (
              <div className="bg-green-500/10 backdrop-blur-lg rounded-xl p-4 border border-green-500/30 mb-6 flex items-center gap-4">
                {spotifyUser.images?.[0] && (
                  <img src={spotifyUser.images[0].url} alt="Profile" className="w-12 h-12 rounded-full" />
                )}
                <div>
                  <p className="text-white font-semibold">Connected: {spotifyUser.display_name}</p>
                  <p className="text-green-300 text-sm">
                    {songList.length} tracks loaded from your top songs
                  </p>
                </div>
              </div>
            )}

            {fetchingSpotify && (
              <div className="text-center py-8">
                <Loader2 className="w-12 h-12 animate-spin text-green-400 mx-auto mb-4" />
                <p className="text-white">Loading your Spotify data...</p>
              </div>
            )}

            <div className="grid md:grid-cols-2 gap-6">
              <div className="space-y-6">
                <div className="bg-white/10 backdrop-blur-lg rounded-2xl p-6 border border-white/20">
                  <h2 className="text-xl font-bold text-white mb-4">Your Music ({songList.length})</h2>
                  <div className="flex gap-2 mb-4">
                    <input
                      type="text"
                      value={currentInput}
                      onChange={(e) => setCurrentInput(e.target.value)}
                      onKeyPress={(e) => e.key === 'Enter' && addSong()}
                      placeholder="Add more songs..."
                      className="flex-1 px-4 py-2 rounded-lg bg-white/20 text-white placeholder-green-200 border border-white/30 focus:outline-none focus:ring-2 focus:ring-green-400"
                    />
                    <button
                      onClick={addSong}
                      className="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold"
                    >
                      <Plus className="w-5 h-5" />
                    </button>
                  </div>

                  <div className="space-y-2 mb-4 max-h-60 overflow-y-auto">
                    {songList.map((song, idx) => (
                      <div
                        key={idx}
                        className="flex items-center justify-between bg-white/10 rounded-lg px-4 py-2 border border-white/20"
                      >
                        <span className="text-white text-sm truncate">{song}</span>
                        <button
                          onClick={() => removeSong(idx)}
                          className="text-red-300 hover:text-red-400 ml-2"
                        >
                          <X className="w-4 h-4" />
                        </button>
                      </div>
                    ))}
                    {songList.length === 0 && (
                      <p className="text-green-300 text-sm text-center py-4">
                        Connect Spotify or add songs manually
                      </p>
                    )}
                  </div>

                  <button
                    onClick={vectorizeProfile}
                    disabled={vectorizing || songList.length === 0}
                    className="w-full px-4 py-3 bg-gradient-to-r from-green-500 to-blue-500 hover:from-green-600 hover:to-blue-600 disabled:from-gray-500 disabled:to-gray-600 text-white rounded-lg font-semibold flex items-center justify-center gap-2"
                  >
                    {vectorizing ? (
                      <>
                        <Loader2 className="w-5 h-5 animate-spin" />
                        Vectorizing...
                      </>
                    ) : (
                      <>
                        <Zap className="w-5 h-5" />
                        Vectorize Profile
                      </>
                    )}
                  </button>
                </div>

                {vectorProfile && (
                  <div className="bg-white/10 backdrop-blur-lg rounded-2xl p-6 border border-white/20">
                    <h3 className="text-lg font-bold text-white mb-3">Your Vector Profile</h3>
                    <p className="text-green-200 text-sm mb-4">{vectorProfile.summary}</p>
                    
                    <div className="space-y-3">
                      {Object.entries(vectorProfile.profile).map(([key, value]) => (
                        <div key={key}>
                          <div className="text-white text-sm font-semibold mb-1 capitalize">{key}</div>
                          {typeof value === 'object' ? (
                            <div className="flex flex-wrap gap-2">
                              {Object.entries(value).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([k, v]) => (
                                <span
                                  key={k}
                                  className="px-2 py-1 bg-green-500/50 rounded text-white text-xs"
                                >
                                  {k}: {(v * 100).toFixed(0)}%
                                </span>
                              ))}
                            </div>
                          ) : (
                            <div className="w-full bg-white/20 rounded-full h-2">
                              <div
                                className="bg-gradient-to-r from-green-400 to-blue-400 h-2 rounded-full"
                                style={{ width: `${value * 100}%` }}
                              />
                            </div>
                          )}
                        </div>
                      ))}
                    </div>

                    <button
                      onClick={generateRecommendations}
                      disabled={loading}
                      className="w-full mt-4 px-4 py-3 bg-green-500 hover:bg-green-600 disabled:bg-green-700 text-white rounded-lg font-bold flex items-center justify-center gap-2"
                    >
                      {loading ? (
                        <>
                          <Loader2 className="w-5 h-5 animate-spin" />
                          Generating...
                        </>
                      ) : (
                        <>
                          <Sparkles className="w-5 h-5" />
                          Generate Recommendations
                        </>
                      )}
                    </button>
                  </div>
                )}
              </div>

              <div className="space-y-4">
                {recommendations.length > 0 && (
                  <>
                    <h2 className="text-2xl font-bold text-white flex items-center gap-2">
                      <Sparkles className="w-6 h-6 text-green-400" />
                      Recommendations
                    </h2>
                    {recommendations.map((rec, idx) => (
                      <div
                        key={idx}
                        className="bg-white/10 backdrop-blur-lg rounded-xl p-5 border border-white/20 hover:bg-white/15 transition-colors"
                      >
                        <div className="flex items-start gap-4">
                          <div className="flex-shrink-0 w-12 h-12 bg-gradient-to-br from-green-500 to-blue-500 rounded-full flex items-center justify-center text-white font-bold">
                            {idx + 1}
                          </div>
                          <div className="flex-1">
                            <div className="flex items-start justify-between mb-2">
                              <div>
                                <h3 className="text-lg font-bold text-white">{rec.song}</h3>
                                <p className="text-green-200 text-sm">by {rec.artist}</p>
                              </div>
                              <div className="text-green-400 font-bold text-lg">
                                {(rec.matchScore * 100).toFixed(0)}%
                              </div>
                            </div>
                            <p className="text-green-100 text-sm">{rec.matchReason}</p>
                          </div>
                        </div>
                      </div>
                    ))}
                  </>
                )}

                {!vectorProfile && recommendations.length === 0 && (
                  <div className="bg-white/5 backdrop-blur-lg rounded-2xl p-12 border border-white/10 text-center">
                    <Music className="w-20 h-20 text-green-300/50 mx-auto mb-4" />
                    <p className="text-green-200 text-lg">
                      {spotifyToken ? 'Vectorize your profile to see recommendations' : 'Connect Spotify or add songs to begin'}
                    </p>
                  </div>
                )}
              </div>
            </div>

            {error && (
              <div className="mt-4 p-4 bg-red-500/20 border border-red-500/50 rounded-lg text-red-200 text-center">
                {error}
              </div>
            )}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SpotifyVectorRecommender />);
  </script>
</body>
</html>